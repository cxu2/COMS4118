# System Calls

- OS's puts kernel code in different places, although they tend to preserve the typical address space
- one copy of kernel code/data structure are all present (mapped) to every processes (from the kernel space, in which you can do kmalloc etc).
- CPU has access to the physical physical address to actually do stuff, and that needs a code that does this translation from virtual address space to the physical address space.
- user uses syscall -> jumps to a piece of code in library -> turns on CPU to privileged mode -> enter super user to trigger the kernel mode -> run the predefined calls in the kernel. user does not know what actually happened, just hand the syscall job to the kernel by invoking an entry point
- syscalls are OS specific
- hardware raises voltage to grab CPU attention to raise an interruption
- x86 deal with traps the same way dealing the interruptions and jump to the predefined routine that deals with that.
- three different kinds of signal: hardware, processor and software

- signal raised, CPU needs to change it unprivileged user mode to privileged kernel mode make hardware jump to routine. In order to serve the device interrupt kernel has to change its mode by the CPU
- hardware timer is a sequence of interrupts generated periodicly by oscillator, any time in between, a keyboard can be generated by yourself.
- software interrupt, which allows programs to run certain instructions and and generate the signal. Especially useful for syscalls.
- Exceptions/Trap: The CPU triggers interrupt like exceptions on things like dividing by zero

- Write() syscal example:
  - int -> interrupt, making sure the cpu is transitioned to kernel mode, and when done it returns to user mode. 0x80 is address fpr system_call in IDT. \__NR__write is a # defined constant

- debugger is another source of interruptions. x86 reserves a int 0x3 one byte for debugger for break points.

- Syscall parameter passing:
  - user calls get_usr, put_usr etc to talk to the kernel and might involve kmalloc

- No need to pay attention to slide page 13, 14 the naming conventions

- A thread is like a process except it shares the entire memory space
- Each thread does own a task struct. In multithreading, one task struct represents a thread.

- strace(): shows what syscalls that program is invoking, works just like valgrind
  - ltrace(): gives you library calls involved.
  - ltrace pwd : calls getcwd() the lib function that gets the current working directory and calls puts()
- execve() allows you to pass environment variables

- strace pwd
- When a program reach the top of the heap is called program break, then you call brk() which raises the ceiling of the heap. Malloc is a lib functionthat calls brk() to the kernel. Pass 0 to brk() gives you the current program break.

- calls mmap2 to allocate some kernel memory. -1 is the passed for file descriptor, works same as mmap, the 2 is for the 64 bits
- .a libraries are static libraries, .so are dynamic libraries (shared object). When running helloWorld.c, not actually calling printf but some loading some stub code from a .so libraries and runs that code. That

- ldconfig -p | grep libc.so
- once opens a .so library (libc.so), it maps the contents to the memory
- in ltrace, it calls puts. and in strace, it calls write. So puts probably calls write internally
